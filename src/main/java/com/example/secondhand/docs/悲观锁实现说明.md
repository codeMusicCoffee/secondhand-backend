# 悲观锁实现说明

## 📋 概述

本系统在库存管理中实现了**悲观锁**机制，结合原有的**Redis分布式锁**，形成了双重并发控制保护，确保在高并发场景下不会出现超卖问题。

## 🔒 悲观锁实现

### 1. ProductRepository 悲观锁查询方法

```java
// 写锁：用于库存修改操作
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdWithPessimisticLock(@Param("id") Long id);

// 批量写锁：用于批量库存操作
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id IN :ids ORDER BY p.id")
List<Product> findByIdsWithPessimisticLock(@Param("ids") List<Long> ids);

// 读锁：用于读取时防止修改
@Lock(LockModeType.PESSIMISTIC_READ)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdWithPessimisticReadLock(@Param("id") Long id);
```

### 2. InventoryService 使用悲观锁

#### 预扣库存
```java
// 🔒 使用悲观锁查询商品（FOR UPDATE）
Optional<Product> productOpt = productRepository.findByIdWithPessimisticLock(productId);
```

#### 恢复库存
```java
// 🔒 使用悲观锁查询商品（FOR UPDATE）
Optional<Product> productOpt = productRepository.findByIdWithPessimisticLock(productId);
```

#### 库存检查（高并发场景）
```java
@Transactional
public boolean checkInventoryWithLock(Long productId, Integer quantity) {
    // 🔒 使用悲观锁查询商品
    Optional<Product> productOpt = productRepository.findByIdWithPessimisticLock(productId);
    // ...
}
```

## 🛡️ 双重并发控制架构

### 第一层：Redis分布式锁
- **作用范围**: 跨JVM实例的分布式环境
- **锁定粒度**: 商品级别
- **超时机制**: 30秒自动释放
- **获取超时**: 5秒等待时间

### 第二层：数据库悲观锁
- **作用范围**: 数据库事务级别
- **锁定粒度**: 行级锁（商品记录）
- **锁定类型**: FOR UPDATE（排他锁）
- **释放时机**: 事务提交或回滚时自动释放

## 🔄 并发控制流程

```
用户下单请求
    ↓
1. 获取Redis分布式锁（商品级别）
    ↓
2. 开启数据库事务
    ↓
3. 使用悲观锁查询商品（FOR UPDATE）
    ↓
4. 检查库存并扣减
    ↓
5. 保存商品记录
    ↓
6. 提交事务（释放悲观锁）
    ↓
7. 释放Redis分布式锁
```

## ⚡ 性能优化

### 数据库索引优化
```sql
-- 主键索引（通常已存在）
PRIMARY KEY (id)

-- 库存字段索引
CREATE INDEX idx_product_quantity ON product(quantity);

-- 状态字段索引
CREATE INDEX idx_product_status ON product(status);

-- 复合索引
CREATE INDEX idx_product_status_quantity ON product(status, quantity);
```

### 锁定顺序优化
- 按商品ID排序获取锁，避免死锁
- 批量操作时使用 `ORDER BY p.id` 确保锁定顺序一致

## 🎯 适用场景

### 使用悲观锁的场景
1. **库存扣减**: 订单创建时的库存预扣
2. **库存恢复**: 订单取消时的库存回滚
3. **高并发检查**: 秒杀等高并发场景的库存检查

### 使用普通查询的场景
1. **商品展示**: 前端商品列表显示
2. **库存显示**: 商品详情页库存展示
3. **统计查询**: 后台管理的统计功能

## 🔧 配置说明

### 事务配置
```java
@Transactional  // 必须在事务中使用悲观锁
public boolean reserveInventory(List<OrderItem> orderItems) {
    // 悲观锁操作
}
```

### 超时配置
```properties
# JPA 查询超时（可选）
spring.jpa.properties.javax.persistence.query.timeout=30000

# 数据库连接超时
spring.datasource.hikari.connection-timeout=30000
```

## 🚨 注意事项

### 1. 死锁预防
- 始终按相同顺序获取锁（按商品ID排序）
- 避免长时间持有锁
- 合理设置超时时间

### 2. 性能考虑
- 悲观锁会阻塞其他事务，影响并发性能
- 仅在必要时使用悲观锁
- 优化查询条件，减少锁定时间

### 3. 事务管理
- 悲观锁必须在事务中使用
- 事务提交后锁自动释放
- 异常时确保事务回滚

## 📊 监控指标

### 建议监控的指标
1. **锁等待时间**: 悲观锁获取耗时
2. **死锁次数**: 数据库死锁统计
3. **事务回滚率**: 库存操作失败率
4. **并发成功率**: 高并发场景下的成功率

## 🔮 后续优化建议

1. **分库分表**: 按商品类别分库，减少锁竞争
2. **读写分离**: 查询操作使用从库
3. **缓存预热**: 热门商品库存缓存
4. **异步处理**: 非关键操作异步化

---

*本文档说明了悲观锁在二手商品交易平台中的实现和使用方式，确保系统在高并发场景下的数据一致性。*